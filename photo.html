<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hilbertæ›²çº¿å›¾ç‰‡åŠ å¯†è§£å¯†å™¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Arial', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
            font-size: 2.5em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .section {
            margin-bottom: 40px;
            padding: 25px;
            background: #f8f9fa;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .section h2 {
            color: #495057;
            margin-bottom: 20px;
            font-size: 1.5em;
        }

        .upload-area {
            border: 3px dashed #667eea;
            border-radius: 15px;
            padding: 40px;
            text-align: center;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .upload-area:hover {
            border-color: #764ba2;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.2), rgba(118, 75, 162, 0.2));
        }

        .upload-area.dragover {
            border-color: #28a745;
            background: rgba(40, 167, 69, 0.1);
        }

        input[type="file"] {
            display: none;
        }

        .btn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1em;
            margin: 10px;
            transition: all 0.3s ease;
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
        }

        .btn:disabled {
            background: #6c757d;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .image-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin-top: 20px;
        }

        .image-box {
            flex: 1;
            min-width: 300px;
            max-width: 400px;
            text-align: center;
        }

        .image-box h3 {
            margin-bottom: 15px;
            color: #495057;
        }

        .image-box canvas {
            max-width: 100%;
            border: 2px solid #dee2e6;
            border-radius: 10px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .progress {
            width: 100%;
            height: 6px;
            background: #e9ecef;
            border-radius: 3px;
            margin: 20px 0;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s ease;
        }

        .info {
            background: #d1ecf1;
            color: #0c5460;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #17a2b8;
        }

        .error {
            background: #f8d7da;
            color: #721c24;
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
            border-left: 4px solid #dc3545;
        }

        .status {
            text-align: center;
            margin: 20px 0;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”’ Hilbertæ›²çº¿å›¾ç‰‡åŠ å¯†è§£å¯†å™¨</h1>
        
        <div class="info">
            <strong>ä½¿ç”¨è¯´æ˜ï¼š</strong><br>
            1. é€‰æ‹©è¦åŠ å¯†çš„å›¾ç‰‡æ–‡ä»¶ï¼ˆæ”¯æŒ PNG, JPG, JPEG æ ¼å¼ï¼‰<br>
            2. é€‰æ‹©è¾“å‡ºåˆ†è¾¨ç‡ï¼š1080P(å¿«é€Ÿ)ã€2K(å¹³è¡¡)ã€4K(æœ€é«˜ç”»è´¨)æˆ–è‡ªé€‚åº”<br>
            3. ç‚¹å‡»"åŠ å¯†å›¾ç‰‡"æŒ‰é’®è¿›è¡ŒåŠ å¯†<br>
            4. ä¸‹è½½æŒ‡å®šåˆ†è¾¨ç‡çš„å›¾ç‰‡æ–‡ä»¶<br>
            5. è¦è§£å¯†æ—¶ï¼Œä¸Šä¼ åŠ å¯†åçš„å›¾ç‰‡ï¼Œç‚¹å‡»"è§£å¯†å›¾ç‰‡"æŒ‰é’®
        </div>

        <div class="section">
            <h2>ğŸ“ é€‰æ‹©å›¾ç‰‡</h2>
            <div class="upload-area" id="uploadArea">
                <p>ç‚¹å‡»è¿™é‡Œé€‰æ‹©å›¾ç‰‡æ–‡ä»¶<br>æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤åŒºåŸŸ</p>
                <input type="file" id="imageInput" accept="image/*">
            </div>
            <div class="status" id="status"></div>
        </div>

        <div class="section">
            <h2>ğŸ”§ æ“ä½œæ§åˆ¶</h2>
            
            <div style="margin-bottom: 20px;">
                <label for="resolutionSelect" style="display: block; margin-bottom: 10px; font-weight: bold; color: #495057;">
                    ğŸ“ é€‰æ‹©è¾“å‡ºåˆ†è¾¨ç‡ï¼š
                </label>
                <select id="resolutionSelect" style="padding: 10px 15px; border: 2px solid #e9ecef; border-radius: 10px; font-size: 1em; background: white; cursor: pointer; width: 250px;">
                    <option value="1080">1080P (1920x1080) - å¿«é€Ÿå¤„ç†</option>
                    <option value="2048">2K (2048x2048) - å¹³è¡¡ç”»è´¨</option>
                    <option value="4096" selected>4K (4096x4096) - æœ€é«˜ç”»è´¨</option>
                    <option value="auto">è‡ªé€‚åº” - æ ¹æ®åŸå›¾è‡ªåŠ¨é€‰æ‹©</option>
                </select>
            </div>
            
            <button class="btn" id="encryptBtn" disabled>ğŸ”’ åŠ å¯†å›¾ç‰‡</button>
            <button class="btn" id="decryptBtn" disabled>ğŸ”“ è§£å¯†å›¾ç‰‡</button>
            <button class="btn" id="downloadBtn" disabled>ğŸ’¾ ä¸‹è½½å›¾ç‰‡</button>
            
            <div class="progress" id="progressContainer" style="display: none;">
                <div class="progress-bar" id="progressBar"></div>
            </div>
            
            <div class="info" style="margin-top: 15px; font-size: 0.9em;">
                <strong>åˆ†è¾¨ç‡è¯´æ˜ï¼š</strong><br>
                â€¢ <strong>1080P</strong>: é€‚åˆå¿«é€Ÿå¤„ç†ï¼Œæ–‡ä»¶å°(~5MB)<br>
                â€¢ <strong>2K</strong>: å¹³è¡¡ç”»è´¨å’Œå¤„ç†é€Ÿåº¦(~15MB)<br>
                â€¢ <strong>4K</strong>: æœ€é«˜ç”»è´¨ï¼Œå¤„ç†æ—¶é—´è¾ƒé•¿(~30MB)<br>
                â€¢ <strong>è‡ªé€‚åº”</strong>: æ ¹æ®åŸå›¾å°ºå¯¸è‡ªåŠ¨é€‰æ‹©æœ€ä½³åˆ†è¾¨ç‡
            </div>
        </div>

        <div class="section">
            <h2>ğŸ–¼ï¸ å›¾ç‰‡é¢„è§ˆ</h2>
            <div class="image-container">
                <div class="image-box">
                    <h3>åŸå§‹å›¾ç‰‡</h3>
                    <canvas id="originalCanvas"></canvas>
                </div>
                <div class="image-box">
                    <h3>å¤„ç†åå›¾ç‰‡</h3>
                    <canvas id="processedCanvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <script>
        class HilbertImageEncryptor {
            constructor() {
                this.originalCanvas = document.getElementById('originalCanvas');
                this.processedCanvas = document.getElementById('processedCanvas');
                this.originalCtx = this.originalCanvas.getContext('2d');
                this.processedCtx = this.processedCanvas.getContext('2d');
                this.currentImageData = null;
                this.isEncrypted = false;
                
                this.setupEventListeners();
            }

            setupEventListeners() {
                const uploadArea = document.getElementById('uploadArea');
                const imageInput = document.getElementById('imageInput');
                const encryptBtn = document.getElementById('encryptBtn');
                const decryptBtn = document.getElementById('decryptBtn');
                const downloadBtn = document.getElementById('downloadBtn');

                // æ–‡ä»¶ä¸Šä¼ 
                uploadArea.addEventListener('click', () => imageInput.click());
                uploadArea.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    uploadArea.classList.add('dragover');
                });
                uploadArea.addEventListener('dragleave', () => {
                    uploadArea.classList.remove('dragover');
                });
                uploadArea.addEventListener('drop', (e) => {
                    e.preventDefault();
                    uploadArea.classList.remove('dragover');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFileSelect(files[0]);
                    }
                });

                imageInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFileSelect(e.target.files[0]);
                    }
                });

                // åˆ†è¾¨ç‡é€‰æ‹©å˜åŒ–æ—¶é‡æ–°å¤„ç†å›¾ç‰‡
                const resolutionSelect = document.getElementById('resolutionSelect');
                resolutionSelect.addEventListener('change', () => {
                    if (this.currentImageData && this.originalWidth && this.originalHeight) {
                        // é‡æ–°åˆ›å»ºå›¾ç‰‡å¯¹è±¡å¹¶é‡æ–°åŠ è½½
                        const img = new Image();
                        img.onload = () => {
                            this.loadImage(img);
                        };
                        // ä»å½“å‰canvasè·å–å›¾ç‰‡æ•°æ®
                        img.src = this.originalCanvas.toDataURL();
                    }
                });
                encryptBtn.addEventListener('click', () => this.encryptImage());
                decryptBtn.addEventListener('click', () => this.decryptImage());
                downloadBtn.addEventListener('click', () => this.downloadImage());
            }

            handleFileSelect(file) {
                if (!file.type.startsWith('image/')) {
                    this.showStatus('è¯·é€‰æ‹©æœ‰æ•ˆçš„å›¾ç‰‡æ–‡ä»¶ï¼', 'error');
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        this.loadImage(img);
                        this.showStatus('å›¾ç‰‡åŠ è½½æˆåŠŸï¼', 'success');
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            loadImage(img) {
                // å­˜å‚¨åŸå§‹å›¾ç‰‡ä¿¡æ¯
                this.originalWidth = img.width;
                this.originalHeight = img.height;
                
                // æ ¹æ®ç”¨æˆ·é€‰æ‹©ç¡®å®šç›®æ ‡åˆ†è¾¨ç‡
                const targetResolution = this.getTargetResolution();
                const size = this.getNearestPowerOfTwo(Math.max(img.width, img.height), targetResolution);
                
                // æ˜¾ç¤ºç”»å¸ƒä¿æŒåˆç†å°ºå¯¸ä¾¿äºé¢„è§ˆ
                const displaySize = Math.min(size, 400);
                this.originalCanvas.style.width = displaySize + 'px';
                this.originalCanvas.style.height = displaySize + 'px';
                this.processedCanvas.style.width = displaySize + 'px';
                this.processedCanvas.style.height = displaySize + 'px';

                // å®é™…ç”»å¸ƒä½¿ç”¨é€‰å®šåˆ†è¾¨ç‡
                this.originalCanvas.width = size;
                this.originalCanvas.height = size;
                this.processedCanvas.width = size;
                this.processedCanvas.height = size;
                this.canvasSize = size;

                // ç»˜åˆ¶é«˜è´¨é‡åŸå§‹å›¾ç‰‡
                this.originalCtx.fillStyle = 'white';
                this.originalCtx.fillRect(0, 0, size, size);
                
                // ä½¿ç”¨é«˜è´¨é‡ç¼©æ”¾
                this.originalCtx.imageSmoothingEnabled = true;
                this.originalCtx.imageSmoothingQuality = 'high';
                
                const scale = Math.min(size / this.originalWidth, size / this.originalHeight);
                const x = (size - this.originalWidth * scale) / 2;
                const y = (size - this.originalHeight * scale) / 2;
                
                this.originalCtx.drawImage(img, x, y, this.originalWidth * scale, this.originalHeight * scale);
                
                this.currentImageData = this.originalCtx.getImageData(0, 0, size, size);
                this.isEncrypted = false;

                // å¯ç”¨æŒ‰é’®
                document.getElementById('encryptBtn').disabled = false;
                document.getElementById('decryptBtn').disabled = false;
                
                const resolutionName = this.getResolutionName(size);
                this.showStatus(`å›¾ç‰‡åŠ è½½æˆåŠŸï¼è¾“å‡ºåˆ†è¾¨ç‡: ${resolutionName} (${size}x${size}) | åŸå§‹: ${this.originalWidth}x${this.originalHeight}`, 'success');
            }

            getNearestPowerOfTwo(n, maxSize = null) {
                let power = 1;
                while (power < n) {
                    power *= 2;
                }
                if (maxSize) {
                    return Math.min(power, maxSize);
                }
                return power;
            }

            getTargetResolution() {
                const select = document.getElementById('resolutionSelect');
                const value = select.value;
                
                if (value === 'auto') {
                    // æ ¹æ®åŸå›¾å°ºå¯¸è‡ªåŠ¨é€‰æ‹©
                    const maxDim = Math.max(this.originalWidth || 0, this.originalHeight || 0);
                    if (maxDim <= 1920) return 2048;  // 2K for images up to 1080p
                    if (maxDim <= 2560) return 2048;  // 2K for QHD
                    return 4096;  // 4K for larger images
                }
                
                return parseInt(value);
            }

            getResolutionName(size) {
                switch(size) {
                    case 1024: return '1080P';
                    case 2048: return '2K';
                    case 4096: return '4K';
                    default: return `${size}x${size}`;
                }
            }

            // ç”ŸæˆHilbertæ›²çº¿åæ ‡åºåˆ—
            generateHilbertCurve(n) {
                const points = [];
                const total = n * n;
                
                for (let i = 0; i < total; i++) {
                    const point = this.hilbertIndexToXY(i, n);
                    points.push(point);
                }
                
                return points;
            }

            // å°†Hilbertæ›²çº¿ç´¢å¼•è½¬æ¢ä¸ºåæ ‡
            hilbertIndexToXY(index, n) {
                let x = 0, y = 0;
                let t = index;
                let s = 1;
                
                while (s < n) {
                    const rx = 1 & (t / 2);
                    const ry = 1 & (t ^ rx);
                    
                    if (ry === 0) {
                        if (rx === 1) {
                            x = s - 1 - x;
                            y = s - 1 - y;
                        }
                        [x, y] = [y, x];
                    }
                    
                    x += s * rx;
                    y += s * ry;
                    t = Math.floor(t / 4);
                    s *= 2;
                }
                
                return { x, y };
            }

            async encryptImage() {
                if (!this.currentImageData) return;

                this.showProgress(true);
                this.showStatus('æ­£åœ¨åŠ å¯†å›¾ç‰‡...', 'info');

                const size = this.originalCanvas.width;
                const imageData = new ImageData(
                    new Uint8ClampedArray(this.currentImageData.data),
                    size,
                    size
                );

                // ç”ŸæˆHilbertæ›²çº¿è·¯å¾„
                const hilbertPath = this.generateHilbertCurve(size);
                
                // åˆ›å»ºæ–°çš„åƒç´ æ•°æ®
                const newData = new Uint8ClampedArray(imageData.data.length);
                
                // ä½¿ç”¨Hilbertæ›²çº¿é‡æ–°æ’åˆ—åƒç´ 
                for (let i = 0; i < hilbertPath.length; i++) {
                    const originalPoint = hilbertPath[i];
                    const newPoint = hilbertPath[(i + Math.floor(hilbertPath.length / 3)) % hilbertPath.length];
                    
                    const originalIndex = (originalPoint.y * size + originalPoint.x) * 4;
                    const newIndex = (newPoint.y * size + newPoint.x) * 4;
                    
                    newData[newIndex] = imageData.data[originalIndex];
                    newData[newIndex + 1] = imageData.data[originalIndex + 1];
                    newData[newIndex + 2] = imageData.data[originalIndex + 2];
                    newData[newIndex + 3] = imageData.data[originalIndex + 3];
                    
                    if (i % 1000 === 0) {
                        this.updateProgress((i / hilbertPath.length) * 100);
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }

                const encryptedImageData = new ImageData(newData, size, size);
                this.processedCtx.putImageData(encryptedImageData, 0, 0);
                
                this.isEncrypted = true;
                this.showProgress(false);
                this.showStatus('å›¾ç‰‡åŠ å¯†å®Œæˆï¼', 'success');
                document.getElementById('downloadBtn').disabled = false;
            }

            async decryptImage() {
                if (!this.currentImageData) return;

                this.showProgress(true);
                this.showStatus('æ­£åœ¨è§£å¯†å›¾ç‰‡...', 'info');

                const size = this.originalCanvas.width;
                const imageData = new ImageData(
                    new Uint8ClampedArray(this.currentImageData.data),
                    size,
                    size
                );

                // ç”ŸæˆHilbertæ›²çº¿è·¯å¾„
                const hilbertPath = this.generateHilbertCurve(size);
                
                // åˆ›å»ºæ–°çš„åƒç´ æ•°æ®
                const newData = new Uint8ClampedArray(imageData.data.length);
                
                // ä½¿ç”¨é€†å‘çš„Hilbertæ›²çº¿æ¢å¤åƒç´ 
                for (let i = 0; i < hilbertPath.length; i++) {
                    const encryptedPoint = hilbertPath[(i + Math.floor(hilbertPath.length / 3)) % hilbertPath.length];
                    const originalPoint = hilbertPath[i];
                    
                    const encryptedIndex = (encryptedPoint.y * size + encryptedPoint.x) * 4;
                    const originalIndex = (originalPoint.y * size + originalPoint.x) * 4;
                    
                    newData[originalIndex] = imageData.data[encryptedIndex];
                    newData[originalIndex + 1] = imageData.data[encryptedIndex + 1];
                    newData[originalIndex + 2] = imageData.data[encryptedIndex + 2];
                    newData[originalIndex + 3] = imageData.data[encryptedIndex + 3];
                    
                    if (i % 1000 === 0) {
                        this.updateProgress((i / hilbertPath.length) * 100);
                        await new Promise(resolve => setTimeout(resolve, 1));
                    }
                }

                const decryptedImageData = new ImageData(newData, size, size);
                this.processedCtx.putImageData(decryptedImageData, 0, 0);
                
                this.isEncrypted = false;
                this.showProgress(false);
                this.showStatus('å›¾ç‰‡è§£å¯†å®Œæˆï¼', 'success');
                document.getElementById('downloadBtn').disabled = false;
            }

            downloadImage() {
                const canvas = this.processedCanvas;
                const link = document.createElement('a');
                const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
                const resolutionName = this.getResolutionName(this.canvasSize);
                const prefix = this.isEncrypted ? 'encrypted' : 'decrypted';
                const filename = `${prefix}_${resolutionName}_${timestamp}.png`;
                
                // ä½¿ç”¨æœ€é«˜è´¨é‡å¯¼å‡º
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    link.href = url;
                    link.download = filename;
                    link.click();
                    URL.revokeObjectURL(url);
                    
                    const sizeInMB = (blob.size / 1024 / 1024).toFixed(2);
                    this.showStatus(`${resolutionName}å›¾ç‰‡å·²ä¸‹è½½: ${filename} (${sizeInMB}MB)`, 'success');
                }, 'image/png', 1.0); // ä½¿ç”¨PNGæ ¼å¼å’Œæœ€é«˜è´¨é‡
            }

            showProgress(show) {
                const container = document.getElementById('progressContainer');
                container.style.display = show ? 'block' : 'none';
                if (!show) {
                    this.updateProgress(0);
                }
            }

            updateProgress(percent) {
                const bar = document.getElementById('progressBar');
                bar.style.width = percent + '%';
            }

            showStatus(message, type = 'info') {
                const status = document.getElementById('status');
                status.textContent = message;
                status.className = 'status ' + type;
                
                setTimeout(() => {
                    status.textContent = '';
                    status.className = 'status';
                }, 3000);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        document.addEventListener('DOMContentLoaded', () => {
            new HilbertImageEncryptor();
        });
    </script>
</body>
</html>